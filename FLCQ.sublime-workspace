{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"C",
				"CREF2_AVG_OFFSET"
			],
			[
				"CR",
				"CREF1_AVG_OFFSET"
			],
			[
				"re",
				"reasonable_c0l0"
			],
			[
				"ee",
				"eeprom_write_byte"
			],
			[
				"avg",
				"avg_offset"
			],
			[
				"eeprom_re",
				"eeprom_read_byte"
			],
			[
				"E",
				"EEPROM"
			],
			[
				"f2",
				"f2_label"
			],
			[
				"f1_",
				"f1_label"
			],
			[
				"bu",
				"button_id"
			],
			[
				"fre",
				"frequency_pack"
			],
			[
				"tab_",
				"tab_inductance"
			],
			[
				"TFre",
				"TwoFreq"
			],
			[
				"delta_",
				"delta_temperature_f1_label"
			],
			[
				"ca",
				"calibration_temperature"
			],
			[
				"curren",
				"current_temperature_f1_label"
			],
			[
				"error",
				"error_label"
			],
			[
				"F",
				"Flcq"
			],
			[
				"update",
				"update_capacitance_tab_cref"
			],
			[
				"cref1",
				"cref1_text"
			],
			[
				"set",
				"set_ids"
			],
			[
				"indu",
				"inductance_results_label"
			],
			[
				"up",
				"update"
			],
			[
				"cref",
				"cref_eeprom_active"
			],
			[
				"ind",
				"inductance_cref2_label"
			],
			[
				"ta",
				"tab_inductance"
			],
			[
				"e",
				"cref_eeprom_active"
			],
			[
				"input",
				"input_id"
			],
			[
				"is",
				"is_init"
			],
			[
				"A",
				"ActionButton"
			],
			[
				"pa",
				"parent_id"
			],
			[
				"fr",
				"frequency_pack"
			],
			[
				"te",
				"temperature"
			],
			[
				"to",
				"to_string"
			],
			[
				"ref",
				"ref_frequency"
			],
			[
				"to_",
				"to_string"
			],
			[
				"port",
				"port_name"
			],
			[
				"flc",
				"flcq_is_init"
			],
			[
				"sele",
				"selected_uart_port"
			],
			[
				"scrollbar",
				"scrollbar"
			],
			[
				"W",
				"WIDTH"
			],
			[
				"label",
				"label_port"
			],
			[
				"po",
				"port"
			],
			[
				"la",
				"label_capacity"
			],
			[
				"label_",
				"label_frequency"
			],
			[
				"wh",
				"wh_of"
			],
			[
				"Se",
				"SerialPort"
			],
			[
				"serialport",
				"serialport"
			],
			[
				"tab",
				"tab_frequency_calibration"
			],
			[
				"rig",
				"right_text"
			],
			[
				"middl",
				"middle_text"
			],
			[
				"middle",
				"middle_col"
			],
			[
				"ti",
				"to_string"
			],
			[
				"overf",
				"overflows_array"
			],
			[
				"N",
				"n_overflow"
			],
			[
				"read",
				"read_data"
			],
			[
				"a",
				"adrress"
			],
			[
				"over",
				"overflows"
			],
			[
				"freq",
				"frequency"
			],
			[
				"fe",
				"frequency"
			],
			[
				"ge",
				"get_temperature"
			],
			[
				"_",
				"_byte_array"
			],
			[
				"wri",
				"write_data"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Cargo.toml",
			"settings":
			{
				"buffer_size": 542,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/main.rs",
			"settings":
			{
				"buffer_size": 80735,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/commands.rs",
			"settings":
			{
				"buffer_size": 1713,
				"encoding": "UTF-8",
				"line_ending": "Windows",
				"name": "fff"
			}
		},
		{
			"file": "Cargo.lock",
			"settings":
			{
				"buffer_size": 65004,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "extern crate clap;\nextern crate serialport;\n\n//use std::io::{self, Write};\n//use std::time::Duration;\n\n//use serialport::prelude::*;\n\nfn timeout<P: serialport::SerialPort, T: std::fmt::Display>(port: &P, s: &T) -> () {\n    match port.name() {\n        Some(name) => println!(\"{}: Timeout port \\\"{}\\\"\", s, name),\n        None => println!(\"\\\"{}\\\" port name is not avilable\", s),\n    }\n}\n\nfn eeprom_write_byte<P: serialport::SerialPort>(port: &P, address: &u8, data: &u8) -> () {\n    let write_data = vec![0x03u8, *data, *address, 0xFFu8, 0xFFu8];\n\n    match port.write(&write_data) {\n        Ok(_) => {\n            let mut read_data = vec![0; 5];\n            match port.read(&mut read_data) {\n                Ok(_n) => {\n                    if read_data[0] == 0x04\n                        && read_data[1] == *data\n                        && read_data[2] == *address\n                        && _n == 5\n                    {\n                        ()\n                    }\n                }\n                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => timeout(\n                    port,\n                    &std::string::String::from(\" [eeprom write byte respond ] \"),\n                ),\n                Err(e) => eprintln!(\"{:?}\", e),\n            }\n        }\n        Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => timeout(\n            port,\n            &std::string::String::from(\" [eeprom write byte request ] \"),\n        ),\n        Err(e) => panic!(\"Error while writing data to the port: {}\", e),\n    };\n}\n\nfn eeprom_read_byte<P: serialport::SerialPort>(port: &P, adrress: &u8) -> u8 {\n    let write_data = vec![0x05u8, *adrress, 0xFFu8, 0xFFu8];\n\n    match port.write(&write_data) {\n        Ok(_) => (),\n        Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => timeout(\n            port,\n            &std::string::String::from(\" [ eeprom read byte request ] \"),\n        ),\n        Err(e) => eprintln!(\"{:?}\", e),\n    }\n    let mut read_data = vec![0; 5];\n    match port.read(&mut read_data) {\n        Ok(_n) => {\n            //println!(\"{} {} {}\", read_data[0], read_data[1], read_data[2]);\n            if read_data[0] == 0x04 && read_data[2] == *adrress && _n == 5 {\n                read_data[1]\n            } else {\n                eprintln!(\"return address is different as in read command\");\n                0xFFu8\n            }\n        }\n        Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => {\n            timeout(port, &std::string::String::from(\" [ eeprom read byte ] \"));\n            0xFFu8\n        }\n        Err(e) => {\n            eprintln!(\"{:?}\", e);\n            0xFFu8\n        }\n    }\n}\n\npub struct Flcq {\n    port: Option<Box<dyn serialport::SerialPort>>,\n}\n\nimpl Flcq {\n    fn new<T: std::fmt::Display + AsRef<std::ffi::OsStr> + ?Sized>(port_name: &T) -> Self {\n        let mut settings: serialport::SerialPortSettings = Default::default();\n        settings.timeout = std::time::Duration::from_millis(100000);\n        settings.baud_rate = 57600u32;\n        match serialport::open_with_settings(&port_name, &settings) {\n            Ok(result) => Flcq { port: Some(result) },\n            Err(e) => {\n                eprintln!(\"Failed to open \\\"{}\\\". Error: {}\", port_name, e);\n                ::std::process::exit(1);\n            }\n        }\n    }\n}\n\nimpl Flcq {\n    pub fn disconnect(&mut self) {\n        self.port = None;\n    }\n}\n\nimpl Flcq {}\n\nimpl Flcq {\n        fn eeprom_write_f64(&mut self, _adrress: &u8, _value: &f64) -> () {\n        let b = _value.clone();\n        let _byte_array: f64;\n        unsafe {\n             _byte_array = std::mem::transmute::<f64, [u8; 8]>(b);\n        }\n            for (i, item) in _byte_array.iter().enumerate() {\n                let adrress = *_adrress + i as u8;\n                //println!(\"{} {}\", i, item);\n                //thread::sleep(std::time::Duration::from_millis(1000));\n                self.eeprom_write_byte(&adrress, &item);\n            }\n        }\n    }\n\n}\n\nimpl Flcq {\n    fn eeprom_write_f64(&mut self, _adrress: &u8, _value: &f64) -> () {\n        let b = _value.clone();\n        let _byte_array: f64;\n        unsafe {\n             _byte_array = std::mem::transmute::<f64, [u8; 8]>(b);\n        }\n            for (i, item) in _byte_array.iter().enumerate() {\n                let adrress = *_adrress + i as u8;\n                //println!(\"{} {}\", i, item);\n                //thread::sleep(std::time::Duration::from_millis(1000));\n                self.eeprom_write_byte(&adrress, &item);\n            }\n        }\n    }\n}\n\nimpl Flcq {\n    pub fn eeprom_read_f64(&mut self, _adrress: &u8) -> f64 {\n        unsafe {\n            let mut _byte_array = [0u8; 8];\n\n            for i in 0..=7 {\n                let adrress = *_adrress + i as u8;\n                _byte_array[i] = self.eeprom_read_byte(&adrress);\n            }\n            std::mem::transmute::<[u8; 8], f64>(_byte_array)\n        }\n    }\n}\n\nimpl Flcq {\n    fn temperature(&self, _first: u8, _second: u8) -> f64 {\n        let data = [_second, _first];\n        unsafe {\n            let raw = std::mem::transmute::<[u8; 2], u16>(data);\n            let f = raw as f64;\n            f * 0.0625\n        }\n    }\n}\n\n//temperature\nimpl Flcq {\n    pub fn t(&mut self) -> f64 {\n        let write_data = vec![0x09u8, 0x08u8, 0x00u8, 0xFFu8, 0xFFu8];\n        let mut res: f64 = -100.0;\n        match self.port.write(&write_data) {\n            Ok(_) => (),\n            Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                &std::string::String::from(\" [ query for temperature from FLCQ ] \"),\n            ),\n            Err(e) => eprintln!(\"{:?}\", e),\n        };\n        let mut read_data = vec![0; 5];\n        match self.port.read(&mut read_data) {\n            Ok(_n) => {\n                if read_data[0] == 0x0A && _n == 5 {\n                    res = self.temperature(read_data[1], read_data[2])\n                }\n            }\n            Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                &std::string::String::from(\" [ wait for temperature from FLCQ ] \"),\n            ),\n            Err(e) => eprintln!(\"{:?}\", e),\n        }\n        res\n    }\n}\nimpl Flcq {\n    fn frequency(&self, prescaler: u8, tmr0: u8, overflows_array: [u8; 4]) -> f64 {\n        let overflows: u32;\n        unsafe {\n            overflows = std::mem::transmute::<[u8; 4], u32>(overflows_array);\n        }\n        let prescaler_values = [1.0f64, 2.0f64, 4.0f64, 8.0f64, 16.0f64];\n        println!(\n            \"{} {} {}\",\n            overflows,\n            prescaler_values[(prescaler + 1u8) as usize],\n            tmr0 as f64\n        );\n        prescaler_values[(prescaler + 1u8) as usize] * (256.0f64 * overflows as f64 + tmr0 as f64)\n    }\n}\n\nimpl Flcq {\n    pub fn get_frequency_c(&mut self, n: u8) -> f64 {\n        let mut freq: f64 = -10000.0f64;\n        if (0 < n) && (n < 255) {\n            let write_data = vec![0x0Bu8, 0x10u8, 0x00u8, n, 0xFFu8, 0xFFu8];\n            match self.port.write(&write_data) {\n                Ok(_) => (),\n                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                    &std::string::String::from(\" [ query for frequency from FLCQ ] \"),\n                ),\n                Err(e) => eprintln!(\"{:?}\", e),\n            };\n\n            let mut read_data = vec![0; 9];\n\n            match self.port.read(&mut read_data) {\n                Ok(_n) => {\n                    let n_overflow_tmp = [read_data[3], read_data[4], read_data[5], read_data[6]];\n                    let overflows: u32;\n                    unsafe {\n                        overflows = std::mem::transmute::<[u8; 4], u32>(n_overflow_tmp);\n                    }\n                    println!(\"overflows {}\", overflows);\n                    if read_data[0] == 0x06 && _n == 9 {\n                        let n_overflow = [read_data[3], read_data[4], read_data[5], read_data[6]];\n                        freq = self.frequency(read_data[1], read_data[2], n_overflow);\n                    }\n                }\n                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                    &std::string::String::from(\" [ wait for temperature from FLCQ ] \"),\n                ),\n                Err(e) => eprintln!(\"{:?}\", e),\n            }\n        } else {\n            println!(\"wrong averging over {:?}, must be (0 < n < 255) \", n);\n        }\n        freq\n    }\n}\n\nimpl Flcq {\n    fn get_frequency(&mut self, mut n: u8) -> f64 {\n        if (0 < n) && (n < 255) {\n            let write_data = vec![0x07u8, 0x10u8, 0x00u8, n, 0xFFu8, 0xFFu8];\n            match self.port.write(&write_data) {\n                Ok(_) => (),\n                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                    &std::string::String::from(\" [ query for frequency from FLCQ ] \"),\n                ),\n                Err(e) => eprintln!(\"{:?}\", e),\n            };\n\n            let mut frequencies = Vec::new();\n            loop {\n                let mut read_data = vec![0; 9];\n                match self.port.read(&mut read_data) {\n                    Ok(_n) => {\n                        if read_data[0] == 0x06 && _n == 9 {\n                            let n_overflow =\n                                [read_data[3], read_data[4], read_data[5], read_data[6]];\n                            frequencies.push(self.frequency(\n                                read_data[1],\n                                read_data[2],\n                                n_overflow,\n                            ));\n                        }\n                    }\n                    Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => self.timeout(\n                        &std::string::String::from(\" [ wait for temperature from FLCQ ] \"),\n                    ),\n                    Err(e) => eprintln!(\"{:?}\", e),\n                }\n                n = n - 1;\n                if n == 0 {\n                    break;\n                }\n            }\n            let sum = frequencies.iter().sum::<f64>() as f64;\n            sum / frequencies.len() as f64\n        } else {\n            println!(\"wrong averging over {:?}, must be (0 < n < 255) \", n);\n            -1000.0f64\n        }\n    }\n}\n\npub fn ports() -> std::result::Result<std::vec::Vec<serialport::SerialPortInfo>, serialport::Error>\n{\n    serialport::available_ports()\n}\n\npub fn open<T: std::fmt::Display + AsRef<std::ffi::OsStr> + ?Sized>(v: &T) -> Flcq {\n    Flcq::new(v)\n}\n",
			"file": "src/com.rs",
			"file_size": 10218,
			"file_write_time": 132352108779703771,
			"settings":
			{
<<<<<<< Updated upstream
				"buffer_size": 13896,
=======
				"buffer_size": 10483,
>>>>>>> Stashed changes
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/eeprom.rs",
			"settings":
			{
				"buffer_size": 6126,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/Rust Enhanced/RustEnhanced.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"MAKEFILES",
					""
				],
				[
					"MAKEFILES",
					"make"
				],
				[
					"MAKEFILES",
					"clean"
				],
				[
					"Packages/C++/C Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C Single File.sublime-build",
					"Run"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"MAKEFILES",
				"make"
			]
		],
		[
			[
				[
					"MAKEFILES",
					""
				],
				[
					"MAKEFILES",
					"make"
				],
				[
					"MAKEFILES",
					"clean"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"MAKEFILES",
				"clean"
			]
		],
		[
			[
				[
					"MAKEFILES",
					""
				],
				[
					"MAKEFILES",
					"make"
				],
				[
					"MAKEFILES",
					"clean"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/ShellScript/ShellScript.sublime-build",
					""
				]
			],
			[
				"MAKEFILES",
				"clean"
			]
		],
		[
			[
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					""
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Automatic"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Run"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Run (with args)..."
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Check"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Test"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Test (with args)..."
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Bench"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Clean"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Document"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Clippy"
				],
				[
					"Packages/Rust Enhanced/RustEnhanced.sublime-build",
					"Script"
				]
			],
			[
				"Packages/Rust Enhanced/RustEnhanced.sublime-build",
				"Run"
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"rust",
				"Set Syntax: Rust"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 234.0,
		"history":
		[
			"print(sys.path)",
			"import sys",
			"print(sys.path)",
			"import sys",
			"sys.version"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/Vasyl/FLCQ_APP",
		"/C/Users/Vasyl/FLCQ_APP/src",
		"/C/Users/Vasyl/FLCQ_APP/target"
	],
	"file_history":
	[
		"/C/Users/Vasyl/FLCQ_APP/src/commands.rs",
		"/C/Users/Vasyl/FLCQ_APP/FLCQ.sublime-project",
		"/C/Users/Vasyl/FLCQ_APP/src/tmp1hu2yk",
		"/C/Users/Vasyl/FLCQ_APP/src/tmp0c7b0r",
		"/C/Users/Vasyl/FLCQ_APP/src/tmp0ae29w",
		"/C/Users/Vasyl/FLCQ_APP/src/tmp0ab7bv",
		"/C/Users/Vasyl/FLCQ_APP/target/debug/build/glutin-e5de01fa147ee18d/out/test_gl_bindings.rs",
		"/C/Users/Vasyl/FLCQ_APP/src/tmp1n1le9",
		"/C/Users/Vasyl/FLCQ_APP/target/debug/build/glium-95758ff18252008d/out/gl_bindings.rs",
		"/C/Users/Vasyl/Downloads/DHL-Paketmarke_5LYEC43Q8WXG_1_Mustafa_Kocakus.pdf",
		"/C/Users/Vasyl/FLCQ_APP/src/main.rs",
		"/C/Users/Vasyl/FLCQ_APP/src/tmpa9cwk6",
		"/C/Users/Vasyl/FLCQ_APP/.gitignore",
		"/C/Users/Vasyl/FLCQ_APP/Cargo.toml",
		"/C/Users/Vasyl/FLCQ/uart.asm",
		"/C/Users/Vasyl/FLCQ/error",
		"/-0",
		"/C/Users/Vasyl/FLCQ/interrupt.asm",
		"/C/Users/Vasyl/FLCQ/FLCQ.lst",
		"/C/Users/Vasyl/FLCQ/main.asm",
		"/C/Users/Vasyl/AppData/Roaming/Sublime Text 3/Packages/User/Anaconda.sublime-settings",
		"/C/Users/Vasyl/AppData/Roaming/Sublime Text 3/Packages/User/Python.sublime-settings"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"cref1:",
			"show",
			"Input L",
			"L Input",
			"eeprom_undefined",
			"Btoggle",
			"cref1",
			"if_swap_c",
			"Cref2:",
			"eeprom",
			"print",
			"e_cref1",
			"Saved C",
			"eeprom",
			"Saved C",
			");\t",
			"eeprom_lc",
			"history",
			"Vec::ne",
			"save_cef1",
			"TCommand",
			"TSa",
			"eeprom.clon",
			"eeprom",
			"box",
			"save_as",
			"MutFn",
			"eeprom_write_f64",
			"mut flc",
			"\n            ",
			"&41u8",
			"eeprom_write_f64",
			"eeprom_write",
			"BToggle",
			"Save",
			"capacitance_current_temperature_f1_label",
			"widget::Button::new()",
			"END(",
			"widget::Button::new()",
			"justify",
			"ActionButton",
			"f1",
			"ActionButton<F>",
			"TClicked",
			"ActionButton",
			");\n",
			"show(",
			"show",
			"f1_f2",
			"ActionButton",
			"inductance_delta_temperature_f1_label",
			"inductance_f1_label",
			"new",
			"TwoFreq",
			"f1_show",
			"TClicked",
			"|| flcq.is_init()",
			"eeprom_lc",
			"ActionButton",
			"swap_c",
			"cref_source",
			"src_",
			"inductance_eeprom_label",
			"tab_capacitance",
			"cref_sour",
			"550",
			"30.0, 10.0",
			"30.0, 0.0",
			"30.0, 550.0",
			"175",
			"ui.",
			"175",
			"calc_c",
			"frequency1_l",
			"frequency1_c",
			"frequency1_l",
			");\n",
			"=> ",
			"pack",
			"lref_eeprom_active",
			"Input C [edit]",
			"cref_input_active",
			"inductance_cref1_pf",
			"tab_capacitance",
			"label_capacity",
			"capacitance_cref1_label",
			"tab_c",
			"tab_capacitance",
			"flcq.ee",
			"inductance_c_label",
			"println",
			"printf",
			"inductance_l_label",
			"flcq",
			"flcq.eeprom_read_f64(&9u8)",
			"count",
			"frequency_cal",
			"temperature_cal",
			"frequency",
			"temperature(",
			"temperature",
			"get_fre\t",
			"this",
			"this sh",
			"this",
			"frequency",
			"temperatur",
			"Slider",
			"freq_show",
			"ref_frequency",
			"edit_ref_frequency",
			"),\n",
			"}\n",
			"edit_ref_frequency",
			"math",
			"0",
			"ref_frequency_1",
			"update",
			"ref_frequency",
			"count",
			"flcq",
			"},\n",
			"}\n",
			"_port",
			"()\n",
			"if let Some(event)",
			"label_si",
			"font"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Cargo.toml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 542,
						"regions":
						{
						},
						"selection":
						[
							[
								368,
								368
							]
						],
						"settings":
						{
							"syntax": "Packages/TOML/TOML.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/main.rs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 80735,
						"regions":
						{
						},
						"selection":
						[
							[
								54435,
								54435
							]
						],
						"settings":
						{
							"syntax": "Packages/Rust Enhanced/RustEnhanced.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
<<<<<<< Updated upstream
						"translation.y": 25662.0,
=======
						"translation.y": 3457.0,
>>>>>>> Stashed changes
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/commands.rs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1713,
						"regions":
						{
						},
						"selection":
						[
							[
								145,
								145
							]
						],
						"settings":
						{
							"auto_name": "fff",
							"syntax": "Packages/Rust Enhanced/RustEnhanced.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Cargo.lock",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 65004,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/TOML/TOML.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/com.rs",
					"semi_transient": false,
					"settings":
					{
<<<<<<< Updated upstream
						"buffer_size": 13896,
=======
						"buffer_size": 10483,
>>>>>>> Stashed changes
						"regions":
						{
						},
						"selection":
						[
							[
<<<<<<< Updated upstream
								1255,
								1255
=======
								3416,
								3967
>>>>>>> Stashed changes
							]
						],
						"settings":
						{
							"syntax": "Packages/Rust Enhanced/RustEnhanced.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
<<<<<<< Updated upstream
						"translation.y": 342.0,
=======
						"translation.y": 1629.0,
>>>>>>> Stashed changes
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/eeprom.rs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6126,
						"regions":
						{
						},
						"selection":
						[
							[
								5926,
								5926
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/Rust Enhanced/RustEnhanced.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 285.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 28.0
	},
	"input":
	{
		"height": 40.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 204.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Rust Enhanced/RustEnhanced.sublime-build",
	"project": "FLCQ.sublime-project",
	"replace":
	{
		"height": 52.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 280.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
